---
title: "On the equivalence of t-tests, anovas, and linear models"
author: "Brad Duthie"
date: "03/06/2020"
output:
  pdf_document: default
  html_document: default
linkcolor: blue
---

```{r, echo = FALSE}
library(knitr);
```

********************************************************************************

**These are some notes for practice and discussion in Stirling Coding Club, which follow up on a recent meeting in the Stats Discussion Group at the University of Stirling on a [blog post by Jonas Kristoffer Lindel&#248;v](https://lindeloev.github.io/tests-as-linear/). What follows is further demonstration and discussion on linear models in statistics. The goal here is to create a simulated data set, then use it show a bit more clearly the logic underlying linear models in statistics.**

********************************************************************************


Contents
================================================================================

- [Making up data for heights of two plant species](#makeup)
- [Equivalence of `t.test` versus a linear model `lm` in R](#equiv1)
- [Further equivalence of `t.test`, `lm`, and now `aov`](#equiv2)
- [Testing for a difference between means using randomisation](#random)
- [What about when there are more than two groups?](#moregroups)
- [Okay, but what's really happening with three groups?](#whatreally)
- [Can we make this even more elegant, somehow?](#matrices)
- [Some final thoughts](#final)
- [Key bits of code underlying the simulated data](#code)


********************************************************************************


<a name = "makeup">Making up data for heights of two plant species</a>
================================================================================

Let's first make up some data and put it into a data frame. To make everything a bit more concrete, let's just imagine that we're sampling the heights of individual plants from two different species. Hence, we'll have one categorical independent variable, and one continuous dependent variable (plant height). I am just going to make up some data to work with below. The data frame below includes plant height (`height`; since this is a made up example, the units are not important, but let's make them mm) and species ID (`species_ID`). The first 10 plants (each plant is a unique row) are shown below.


```{r, echo = FALSE}
species_n <- c("species_1", "species_2");
sim_pval  <- 0;
while(sim_pval > 0.05 | sim_pval < 0.001){
    species_eg  <- sample(x = species_n, size = 100, replace = TRUE);
    species1    <- as.numeric(species_eg == "species_1");
    species2    <- as.numeric(species_eg == "species_2");
    error       <- rnorm(n = 100, mean = 0, sd = 40);
    height      <- round(150 + (species2 * 20) + error, digits = 2);
    species_ID  <- as.factor(species_eg);
    plant_data  <- data.frame(height, species_ID);
    sim_mod     <- lm(plant_data$height ~ 1 + plant_data$species_ID);
    sim_pval    <- summary(sim_mod)$coefficients[2,4];
}
write.csv(plant_data, file = "two_discrete_x_values.csv", row.names = FALSE);
kable(plant_data[1:10,], align = "l");
```


Using the linear modelling approach [described by Lindel&#248;v](https://lindeloev.github.io/tests-as-linear/), the above data qualify as a simple regression with a discrete x (`species_ID`). Assuming that both species have equal variances in height, we can use a two-sample t-test in R to test the null hypothesis that the mean height of `species_1` is equal to the mean height of `species_2`. To use `t.test`, we can first create two separate vectors of heights, the first one called `species_1`.

```{r}
species_1 <- plant_data$height[plant_data$species_ID == "species_1"];
```

Below shows `species_1`, which includes the heights of all `r length(species_1)` plants whose `species_ID == "species_1"`.

```{r, echo = FALSE}
print(species_1);
```

We can make a separate vector for the remaining heights for the plants of species 2 in the same way.

```{r}
species_2 <- plant_data$height[plant_data$species_ID == "species_2"];
```

These `r length(species_2)` plant heights are shown below.

```{r, echo = FALSE}
print(species_2);
```

It might help to plot a histogram of the two plant species heights side by side.

```{r, echo = FALSE}
hist(species_1, breaks = 10, col = "blue", xlim = c(0, 300), 
     main = "", xlab = "Plant height", cex.lab = 1.25, ylim = c(0, 15));
hist(species_2, breaks = 10, col = "red", add = TRUE)
legend(x = 0, y = 15, fill = c("red", "blue"), 
       legend = c("species_2", "species_1"));
```

Visualising the histogram above, we already have a sense of whether or not knowing species ID is useful for predicting plant height. 

<a name="equiv1">Equivalence of `t.test` versus a linear model `lm` in R</a>
================================================================================

Using our two vectors `species_1` and `species_2`, we can run a t-test as noted [by Lindel&#248;v](https://lindeloev.github.io/tests-as-linear/). 

```{r}
t.test(species_1, species_2, var.equal = TRUE);
```

```{r, echo = FALSE}
ttest1 <- t.test(species_1, species_2, var.equal = TRUE);
```


Reading the output above, we can get the t-statistic `t = ` `r ttest1$statistic`. Given the null hypothesis that the mean height of `species_1` equals the mean height of `species_2`, the probability of getting such an exterme difference between the two observed means is `p-value < ` `r format(ttest1$p.value, scientific = FALSE)` (i.e., unlikely).

But this is not the only way that we can run a t-test. As [Lindel&#248;v](https://lindeloev.github.io/tests-as-linear/) points out, the linear model structure works just fine as well. 

```{r}
lmod1 <- lm(height ~ 1 + species_ID, data = plant_data);
summary(lmod1);
```

Note how the information in the above output matches that from the `t.test` function. In using `lm`, we get a t value in the coefficients table of `summary(lmod1)$coefficients[2,3]`, and a p-value of  `summary(lmod1)$coefficients[2,4]`. We can also see the mean values for `species_1` and `species_2`, though in slightly different forms. From the `t.test` function, we see an estimated mean of `r round(as.numeric(ttest1$estimate[1]), digits = 4)` for species 1 and `r round(as.numeric(ttest1$estimate[2]), digits = 4)` for species 2 (this is at the bottom of the output, under `mean of x mean of y`). In the `lm`, we get the same information in a slightly different form. The estimate in the coefficients table for the intercept is listed as `r round(summary(lmod1)$coefficients[1,1], digits = 3)`; this is the value of the mean height for species 1. 

Where is the value for the mean height of species 2? We get the value for species 2 by adding the estimate of its effect on the line below, such that `r round(summary(lmod1)$coefficients[1,1], digits = 3)` + `r round(summary(lmod1)$coefficients[2,1], digits = 3)` = `r round(summary(lmod1)$coefficients[1,1] + summary(lmod1)$coefficients[2,1], digits = 3)`. To understand why, think back to that `lm` structure, `plant_data$height ~ 1 + plant_data$species_ID`. Recall from [Lindel&#248;v](https://lindeloev.github.io/tests-as-linear/) how this is a short-hand for the familiar equation $y = \beta_{0} + \beta_{1} x$. In this equation, $y$ is the dependent variable plant height, while the value $x$ is what we might call a dummy variable. It indicates whether or not the plant in question is a member of species 2. If yes, then $x = 1$. If no, then $x = 0$. 

Now think about the coefficients $\beta_{0}$ and $\beta_{1}$. Because $x = 0$ whenever `species_ID = species_1`, the predicted plant height $y$ for species 1 is simply $y = \beta_{0} + (\beta_{1} \times 0)$, which simplifies to $y = \beta_{0}$. This is why our `Estimate` of the `(Intercept)` row in the `summary(lmod1)` output equals the mean plant height of species 1. Next, because $x = 1$ whenever `species_ID = species_2`, the predicted plant height $y$ for species 2 is $y = \beta_{0} + (\beta_{1} \times 1)$, which simplifies to $y = \beta_{0} + \beta_{1}$. This is why our `Estimate` of the `plant_data$species_IDspecies_2` row in the `summary(lmod1)` equals `r round(summary(lmod1)$coefficients[2,1], digits = 3)`. It is the amount that needs to be added to the prediction for species 1 to get the prediction for species 2.

To <a name="bintab">further clarify</a> the concept, we can re-write that original two column table from above, but instead of having `species_1` or `species_2` for the `species_ID` column, we can replace it with a column that is `is_species_2`. A value of `is_species_2 = 0` means the plant is species 1, and a value of `is_species_2 = 1` means the plant is species 2.

```{r, echo = FALSE}
is_species_2 <- as.numeric(species_ID == "species_2");
lm_table_eg <- data.frame(height, is_species_2);
kable(lm_table_eg[1:10,], align = "l");
```

If we now plot `is_species_2` on the x-axis, and `height` on the y-axis, we reproduce those same icons as in [Lindel&#248;v](https://lindeloev.github.io/tests-as-linear/). 


```{r, echo = FALSE}
plot(x = lm_table_eg$is_species_2, y = lm_table_eg$height, ylim = c(0, 275), 
     pch = 20, cex.axis = 1.25, cex.lab = 1.25, ylab = "Plant height",
     xlab = "Is species 2: Yes (1) or no (0)");
lines(x = c(0, 1), y = c(summary(lmod1)$coefficients[1,1], 
      summary(lmod1)$coefficients[1,1] + summary(lmod1)$coefficients[2,1]),
      col = "red", lwd = 4);
points(x = 0, y = summary(lmod1)$coefficients[1,1], pch = 17, col = "blue",
       cex = 3);
points(x = 1, y = summary(lmod1)$coefficients[1,1] + 
       summary(lmod1)$coefficients[2,1], pch = 18, col = "orange", cex = 3);
```


The blue triangle shows the mean height of species 1 (i.e., the intercept of the linear model, $\beta_{0}$), and the orange diamond shows the mean height of species 2 (i.e., $\beta_{0} + \beta_{1}$). Since the distance between these two points is one, the slope of the line (rise over run) is identical to the difference between the mean species heights. Hence the reason for why $\beta_{1}$, which we often think about only as the 'slope' is also the difference between means.


<a name="equiv2">Further equivalence of `t.test`, `lm`, and now `aov`</a>
================================================================================

Analysis of variance (ANOVA) tests the null hypothesis that the mean values of groups are all equal. We often think of this being used for group numbers of three or more, but it is worth showing that ANOVA is equivalent to a t-test when the number of groups is two. A one-way ANOVA can be run using the `aov` function in R. Below, I do this for the same `plant_data` table as used for `t.test` and `lm`. 

```{r}
aov_1 <- aov(height ~ species_ID, data = plant_data);
summary(aov_1);
```

Note the `F value` and the `Pr(>F)` (i.e., the p-value) in the table above. The value `r round(summary(aov_1)[[1]][["F value"]][1], digits = 3)` matches the `F-statistic` produced from using `lm` in the previous section, and `r round(summary(aov_1)[[1]][["Pr(>F)"]][1], digits = 4)` is the same p-value that we calculated earlier. The methods are effectively the same.

<a name="random">Testing for a difference between means using randomisation</a>
================================================================================

An alternative approach to testing to the `t.test`, `lm`, and `aov` options above is to use randomisation. Randomisation approaches make fewer assumptions about the data, and I believe that they are often more intuitive. For a full discussion of randomisation techniques, see my [previous notes for Stirling Coding Club](https://stirlingcodingclub.github.io/randomisation/randomisation_notes.html), which goes into much more detail on the underlying logic of randomisation, bootstrap, and Monte Carlo methods. For now, I just want to illustrate how a randomisation approach can get be used for the same null hypothesis testing as shown in the previous methods above. Let us look back at the first ten rows of the data set that I made up.

```{r, echo = FALSE}
kable(plant_data[1:10,], align = "l");
```

When we use null hypothesis testing, what we are asking is this:

> If the difference between group means is the same (null hypothesis), then what is the probability of getting a difference between groups as or more extreme than the difference that we observe in the data?

We might phrase the null hypothesis slightly differently:

> If the difference between group means is random with respect to group identity (null hypothesis), then what is the probability of getting a difference between groups as or more extreme than the difference that we observe in the data?

In other words, what if we were to randomly re-shuffle species IDs, so that we *knew* any difference between mean species heights was attributable to chance? What would the distribution of this difference look like, and where would our actual difference fall within this distribution? The logic behind randomisation here is to randomly re-shuffle group identity many times, then build a distribution for differences between randomly generated groups. We can do this with a bit of code below. First let's get the actual difference between mean heights of species 1 and species 2, i.e., `species[1] - species[2]`. We can use the `tapply` function in R to do this easily.

```{r}
species <- tapply(X = plant_data$height, INDEX = plant_data$species_ID, 
                  FUN = mean);
height_diffs <- as.numeric( species[1] - species[2] );
print(height_diffs);
```

Using a [for loop](https://stirlingcodingclub.github.io/using_loops/loop_notes.html) in R, we can shuffle `species_ID`, then build a distribution showing what the difference between species means would be just due to random chance.


```{r}
null_diff  <- NULL;  # Place where the random diffs will go
iterations <- 99999; # Number of reshuffles
iter       <- 1;     # Start with the first
while(iter < iterations){
  new_species_ID  <- sample(x    = plant_data$species_ID, 
                            size = length(plant_data$species_ID));
  new_species     <- tapply(X = plant_data$height, INDEX = new_species_ID,
                            FUN = mean);
  new_diffs       <- as.numeric( new_species[1] - new_species[2] );
  null_diff[iter] <- new_diffs;
  iter            <- iter + 1;
}
```

Each element in `null_diff` is now a difference between the mean of species 1 and the mean of species 2, given a random shuffling of species IDs. We can look at the distribution of `null_diff` in the histogram below.

```{r, echo = FALSE}
hist(null_diff, main = "", xlab = "Height difference between randomly assigned group means",
     col = "blue");
```

As expected, most differences between randomly assigned species height means are somewhere around zero. Our actual value of `r round(height_diffs, digits = 3)`, which we have calculated several times now, is quite low, and on the extreme tail of the distribution above. What then is the probability of getting a value this extreme if species ID has nothing to do with plant height? The answer is just the total number of values equal or more extreme to the one we observed (`r round(height_diffs, digits = 3)`), divided by the total number of values that we tried (99999 + 1 = 100000; the plus one is for the actual value).

```{r}
p_value <- sum(abs(null_diff) > abs(height_diffs)) / 100000;
```

We get `p_value = ` `r p_value`. Notice how close this value is to the p-value that we obtained using `t.test`, `lm`, and `aov`. This is because the concept is the same; given that the null hypothesis is true, what is the probability of getting a value as or more extreme than the one actually observed?

<a name="moregroups">What about when there are more than two groups?</a>
================================================================================

I want to briefly touch on what happens when there are more than three groups; for example, if we had three species instead of two. Of course, a t-test is now not applicable, but we can still use the linear model and ANOVA approaches. Let's use another data set, but with three species this time.

```{r, echo = FALSE}
species_n <- c("species_1", "species_2", "species_3");
sim_pval  <- 0;
while(sim_pval > 0.05 | sim_pval < 0.001){
    species_eg  <- sample(x = species_n, size = 100, replace = TRUE);
    species1    <- as.numeric(species_eg == "species_1");
    species2    <- as.numeric(species_eg == "species_2");
    species3    <- as.numeric(species_eg == "species_3");
    error       <- rnorm(n = 100, mean = 0, sd = 40);
    height      <- round(150 + (species2 * 20) + error, digits = 2);
    species_ID  <- as.factor(species_eg);
    plant_data  <- data.frame(height, species_ID);
    sim_mod     <- lm(plant_data$height ~ 1 + plant_data$species_ID);
    sim_pval    <- summary(sim_mod)$coefficients[2,4];
}
write.csv(plant_data, file = "three_discrete_x_values.csv", row.names = FALSE);
kable(plant_data[1:10,], align = "l");
```

As already mentioned, `t.test` will not work. But we can run both `lm` and `aov` with the exact same code as before with three groups. I will show `aov` first.

```{r}
aov_2 <- aov(height ~ species_ID, data = plant_data);
summary(aov_2);
```

The F-statistic calculated above is `r round(summary(aov_2)[[1]][["F value"]][1], digits = 3)`, and the p-value is `r round(summary(aov_2)[[1]][["Pr(>F)"]][1], digits = 4)`. The p-value in this case tests the null hypothesis that all groups (i.e., species) have the same mean values (i.e., heights). We can now use the `lm` function to run the same analysis with three groups.

```{r}
lmod2 <- lm(height ~ 1 + species_ID, data = plant_data);
summary(lmod2);
```

We can find the F-statistic and p-value at the very bottom of the output, and note that they are the same as reported by `aov`. But look at what is going on with the `Estimate` values in the table (ignore the `Pr(>|t|)` values in the table). There are now three rows. Again, we can think back to the equation predicting plant height $y$, but now we need another coefficient. The equation can now be expressed as, $y = \beta_{0} + \beta_{1} x_{1} + \beta_{2} x_{2}$. Note that subscripts have been added to $x$. This is because we now have two dummy variables; is the plant species 1 (if so, $x_{1} = 0$ and $x_{2} = 0$), species 2 ($x_{1} = 1$ and $x_{2} = 0$), or species 3 ($x_{1} = 0$ and $x_{2} = 1$)? With these dummy variables, we can now predict the height of species 1,

$$y = \beta_{0} + (\beta_{1} \times 0) + (\beta_{2} \times x_{2}).$$

The above reduces to $y = \beta_{0}$, as with our two species case. The height of species 2 can be predicted as below,

$$y = \beta_{0} + (\beta_{1} \times 1) + (\beta_{2} \times x_{2}).$$
The above reduces to $y = \beta_{0} + \beta_{1}$, again, as with the two species case. Finally, we can use the linear model to predict the height of species 3 plants,

$$y = \beta_{0} + (\beta_{1} \times 0) + (\beta_{2} \times 1).$$

The above reduces to $y = \beta_{0} + \beta_{2}$. Let's use the `tapply` function to see what the mean values of each species are in the new data set.

```{r}
tapply(X = plant_data$height, INDEX = plant_data$species_ID, FUN = mean);
```

```{r, echo = FALSE}
pd_mns <- tapply(X = plant_data$height, INDEX = plant_data$species_ID, FUN = mean);
```


Now look at that output `summary(lmod2)` again. Notice that the estimate of the intercept `(Intercept)` is the same as the mean height of species 1 (`r pd_mns[1]`). Similarly, add the intercept ($\beta_{0}$) to the coefficient in the second row, `plant_data$species_IDspecies_2` (i.e., $\beta_{1}$); this value equals the mean estimate for species 2. Finally, add the intercept to the coefficient in the third row `plant_data$species_IDspecies_3` (i.e., $\beta_{2}$); this value equals the mean estimate for species 3. Once again, we see how the linear model is equivalent to the ANOVA.


<a href="whatreally">Okay, but what's really happening with three groups?</a>
================================================================================

How does this *really* work? We have given R a single column with three different categorical values (species) and somehow ended up with an intercept and two regression coefficients. How can understand this more clearly? Think back to the table [from earlier](#bintab) where we had a column for `is_species_2` with a simple zero or one. We can do the same, but with a new column, to include the ID of species 3. 


```{r, echo = FALSE}
is_species_2 <- as.numeric(species_ID == "species_2");
is_species_3 <- as.numeric(species_ID == "species_3");
lm_table_eg <- data.frame(height, is_species_2, is_species_3);
kable(lm_table_eg[1:10,], align = "l");
```

In fact, for even more clarity, we can add a column for the intercept too.

```{r, echo = FALSE}
the_intercept <- rep(x = 1, length = length(height));
is_species_2  <- as.numeric(species_ID == "species_2");
is_species_3  <- as.numeric(species_ID == "species_3");
lm_table_eg   <- data.frame(height, the_intercept, is_species_2, is_species_3);
kable(lm_table_eg[1:10,], align = "l");
```

Now, we can see the equivalence with the linear model expressed in R from above, `lm(height ~ 1 + species_ID, data = plant_data)`. The formula in `lm` is predicting `height` for individual plants using a linear model that includes the intercept (always 1), plus species ID. This relates now more easily to the equation $y = \beta_{0} + \beta_{1}x_{1} + \beta_{2}x_{2}$. The four terms are reflected in the four columns above. Plant height ($y$) is predicted in the left-most column. The second column is all ones, by which we multipy the intercept ($\beta_{0}$). Columns two and three define the `species_ID` in R, and the $\beta_{1}x_{1} + \beta_{2}x_{2}$ terms of the equation. Note that either $x_{1} = 0$ and $x_{2} = 0$ (the row is species 1), $x_{1} = 1$ and $x_{2} = 0$ (species 2), or $x_{1} = 0$ and $x_{2} = 1$ (species 3). Hence, the coefficients $\beta_{1}$ and $\beta_{2}$ apply only for species 2 and 3, repsectively (and the absence of both occurs for species 1). You should be able to connect this concept with the output of `summary(lmod2)` above.

Now if we want to predict the height of any plant (rows), we can do so just by multiplying the values in columns 2-4 (always 1 or 0) by the corresponding regression coefficients. For example, where `is_species_2 = 0` and `is_species_3 = 0`, we have $y = (\beta_{0} \times 1) + (\beta_{1} \times 0) + (\beta_{2} \times 0)$. Substituting the regression coefficients from the `summary(lmod2)` above, we have,

$$y = ( `r round(summary(lmod2)$coefficients[1,1], digits = 3)` \times 1) + ( `r round(summary(lmod2)$coefficients[2,1], digits = 3)` \times 0) + ( `r round(summary(lmod2)$coefficients[3,1], digits = 3)` \times 0).$$

Note that the above simplifies to `r round(summary(lmod2)$coefficients[1,1], digits = 3)`, the predicted height of species 1. We can do the same for species 2.


$$y = ( `r round(summary(lmod2)$coefficients[1,1], digits = 3)` \times 1) + ( `r round(summary(lmod2)$coefficients[2,1], digits = 3)` \times 1) + ( `r round(summary(lmod2)$coefficients[3,1], digits = 3)` \times 0).$$

The above simplifies to $y = `r round(summary(lmod2)$coefficients[1,1], digits = 3)` + `r round(summary(lmod2)$coefficients[2,1], digits = 3)`$, which equals `r round(summary(lmod2)$coefficients[1,1] + summary(lmod2)$coefficients[2,1], digits = 3)`, the predicted height of species 2. I will leave the predicted height of species 3 to the reader.

Note that we have been working with categorical variables, species. These are represented by ones and zeroes. But we can also imagine that some other continuous variable might be included in the model. For example, perhaps the altitude at which the plant was collected is also potentially important for predicting plant height. The common name for this model would be 'ANCOVA', but all that we would really be doing is adding one more column to the table above. The column would be 'altitude', and would perhaps include values expressing metres above sea level (e.g., `altitude = 23.42, 32.49, 10.02`, and so forth; one for each plant). This value would be multiplied by a new coefficient $\beta_{3}$ to predict plant height, and be represented as a `lm` in R with `lm(height ~ 1 + species_ID + altitude, data = plant_data)`. Its equation would be $y = \beta_{0} + \beta_{1}x_{1} + \beta_{2}x_{2} + \beta_{3}x_{3}$, where altitude is $x_{3}$.


<a name="matrices">Can we make this even more elegant, somehow?</a>
================================================================================

I hope that all of this has further illustrated some of the mathematics and code underlying linear models. Readers who are satisfied can skip this section, but I want to go just one step further and demonstrate how linear model prediction really boils down to **just one equation**. This equation is a generalisation of the by now familiar $y = \beta_{0} + \beta_{1}x$. We can represent independent and dependent variables in the table above using columns of two matrices, $Y$ and $X$. $Y$ is just a vector of 100 plant heights (matching column 1 from the table above),


$$
Y = \begin{pmatrix}
  `r lm_table_eg[1, 1]` \\
  `r lm_table_eg[2, 1]` \\
  `r lm_table_eg[3, 1]` \\
  `r lm_table_eg[4, 1]` \\
  \vdots \\
  `r lm_table_eg[100, 1]` \\
\end{pmatrix}.
$$

Similarly, $X$ is just a matrix with 100 rows and 3 columns indicating the intercept and species identities, as in columns 2-4 above,


$$
X = \begin{pmatrix}
  `r lm_table_eg[1, 2]`, & `r lm_table_eg[1, 3]`, & `r lm_table_eg[1, 4]` \\
  `r lm_table_eg[2, 2]`, & `r lm_table_eg[2, 3]`, & `r lm_table_eg[2, 4]` \\
  `r lm_table_eg[3, 2]`, &`r lm_table_eg[3, 3]`,  & `r lm_table_eg[3, 4]` \\
  `r lm_table_eg[4, 2]`, &`r lm_table_eg[4, 3]`,  & `r lm_table_eg[4, 4]` \\
  \vdots \\
  `r lm_table_eg[100, 2]`, & `r lm_table_eg[100, 3]`, & `r lm_table_eg[100, 4]` \\
\end{pmatrix}.
$$

What we want to figure out now are the coefficients for predicting values in $Y$ (i.e., matrix elements) from values in each of the columns of $X$. In other words, what are the values of $\beta_{0}$, $\beta_{1}$, $\beta_{2}$, which were explained in the last section? We can also represent these values in a matrix $\beta$,


$$
\beta = \begin{pmatrix}
  \beta_{0} \\
  \beta_{1} \\
  \beta_{2} \\
\end{pmatrix}.
$$

We have already figured out what these values are using `lm` in R. They are just the `Estimate` values from the output of `summary(lmod2)` in [an earlier section](#moregroups). But we can also predict them using a bit of matrix algebra, solving for $\beta$ given the values in $Y$ and $X$. The generalisation of $y = \beta_{0} + \beta_{1}x$ is the compact equation below,

$$Y = X \beta.$$

For our data, we could therefore substute for $Y$ and $X$ matrices,

$$
\begin{pmatrix}
  `r lm_table_eg[1, 1]` \\
  `r lm_table_eg[2, 1]` \\
  `r lm_table_eg[3, 1]` \\
  `r lm_table_eg[4, 1]` \\
  \vdots \\
  `r lm_table_eg[100, 1]` \\
\end{pmatrix} = \begin{pmatrix}
  `r lm_table_eg[1, 2]`, & `r lm_table_eg[1, 3]`, & `r lm_table_eg[1, 4]` \\
  `r lm_table_eg[2, 2]`, & `r lm_table_eg[2, 3]`, & `r lm_table_eg[2, 4]` \\
  `r lm_table_eg[3, 2]`, &`r lm_table_eg[3, 3]`,  & `r lm_table_eg[3, 4]` \\
  `r lm_table_eg[4, 2]`, &`r lm_table_eg[4, 3]`,  & `r lm_table_eg[4, 4]` \\
  \vdots \\
  `r lm_table_eg[100, 2]`, & `r lm_table_eg[100, 3]`, & `r lm_table_eg[100, 4]` \\
\end{pmatrix} \begin{pmatrix}
  \beta_{0} \\
  \beta_{1} \\
  \beta_{2} \\
\end{pmatrix}.
$$

Given this equation, we now only need to solve for $\beta$ to get our coefficients predicting $Y$ from $X$. This requires some knowledge of [matrix multiplication](https://en.wikipedia.org/wiki/Matrix_multiplication) and [matrix inversion](https://en.wikipedia.org/wiki/Invertible_matrix). These topics are a lesson in themselves, so I will not go into any detail as to what these matrix operations do. The point is that we are trying to isolate $\beta$ in the equation $Y = X \beta$. My hope is that a rough idea of what is going on is possible even for those unfamiliar with matrix algebra, but feel free to [skip ahead](#betapred).

**Isolating $\beta$ with matrix algebra**

I should note that all of the matrix algebra that you have seen here is thanks to [Dean Adams](https://www.eeob.iastate.edu/people/dean-adams) at Iowa State University (but if you notice any errors, they are mine, not his). The first thing that we need to isolate $\beta$ is to multiply both sides of the equation $Y = \beta X$ by the [transpose](https://en.wikipedia.org/wiki/Transpose) of $X$, $X^{t}$,

$$X^{t} Y = X^{t} X \beta.$$

Next, we multiply both sides by the [inverse](https://en.wikipedia.org/wiki/Invertible_matrix) of $(X^{t}X)$, $(X^{t}X)^{-1}$,

$$\left( X^{t} X \right)^{-1} X^{t} Y = \left( X^{t} X \right)^{-1} X^{t} X \beta.$$

Notice now that on the right side of the equation, we have $\left( X^{t} X \right)^{-1} X^{t} X$. In other words, we multiply the inverse of $(X^{t}X)$ by itself, thereby cancelling itself out (getting the [identity matrix](https://en.wikipedia.org/wiki/Identity_matrix), the matrix algebra equivalent of 1). That leaves us only with $\beta$ on the right hand side of the equation, which is exactly what we want. We can flip this around and put $\beta$ on the left side of the equation,


$$\beta = \left( X^{t} X \right)^{-1} X^{t}Y.$$

Hence, we have isolated $\beta$, and can use the right side of the above equation (where the data are located) to get our predictors.

<a name="betapred">**Using one equation to get predictions of coefficients**</a>.

We now have our equation for getting our prediction coefficients $\beta$,

$$\beta = \left( X^{t} X \right)^{-1} X^{t}Y.$$

Now I will use this equations to rederive our regression coefficients. **Do not worry about the details here**. What I want to show is that the above equation really does get us the same regression coefficents that we got from the output of `summary(lmod2)` [earlier](#moregroups). Here is that output again.

```{r, echo = FALSE}
summary(lmod2);
```

Now let's use the data in `plant_data` to calculate $\beta$ manually instead. Here are the first ten rows of `plant_data` again.

```{r, echo = FALSE}
plant_data <- lm_table_eg;
kable(plant_data[1:10,]);
```

We want to set the first column as a matrix $Y$, and the remaining columns as a matrix $X$.

```{r}
Y <- as.matrix(plant_data[,1]);
X <- as.matrix(plant_data[,2:4]);
```

Here are the first five elements of `Y`.

```{r, echo = FALSE}
print(Y[1:5, ]);
```

Here are the first five rows of `X`.

```{r, echo = FALSE}
print(X[1:5,]);
```

Let's do the matrix algebra now below to get values of $\beta$. Note that in R, [matrix multiplication](https://en.wikipedia.org/wiki/Matrix_multiplication) is denoted by the operation `%*%`. [Matrix inversion](https://en.wikipedia.org/wiki/Invertible_matrix) of `X` is written as `solve(X)`, and matrix [transpose](https://en.wikipedia.org/wiki/Transpose) of `X` is written as `t(X)`. Our expression of $\beta = \left( X^{t} X \right)^{-1} X^{t}Y$ in R is therefore as follows.

```{r}
betas <- solve( t(X) %*% X ) %*% t(X) %*% Y;
```

We can now print `betas` to reveal our coefficients, just as they were reported by `lm`.


```{r}
print(betas);
```

We have just produced our regression coefficients manually, with matrix algebra. 

<a name="final">Some final thoughts</a>
================================================================================

The reason that I have gone through this step by step is to build on our earlier exploration of common statistical tests as linear models. All linear models can be expressed using this common framework. In the above matrix example, note that we could have added as many columns as we wished to $X$. Perhaps we also collected data on the altitude at which we found the plants in our hypothetical example. We could add this information in as an additional column of numbers in $X$, then calculated a new $\beta_{4}$ in exactly the same way. In our new model, this would result in a discrete group predictor (species, in our case), and a continuous variable (altitude). The associated statistical test would commonly be called an ANCOVA, but all that would really have happened is that we would be adding a new column to the list of independent variables. **As an exercise**, think about how we would add interaction terms in $X$.

But wait, there is more. There is no reason why $Y$ needs to be represented by a single column. Maybe we want to predict not just plant height, but plant seed production too. In other words, perhaps we have more than one dependent variable and we need a [multivariate](https://en.wikipedia.org/wiki/Multivariate_statistics) approach (e.g., [MANOVA](https://en.wikipedia.org/wiki/Multivariate_analysis_of_variance)). The same equation for getting $\beta$ works here too; we can think of multivariate linear models in the exact same way as univariate models; we are just adding more columns to $Y$.

I hope that this has been a useful supplement to the already very useful introduction by [Lindel&#248;v](https://lindeloev.github.io/tests-as-linear/). There are details that I have left out for the sake of time, but my goal has been to further simplify the logic and mathematics underying linear models in statistics. 

This document is entirely reproducible. Because the data are simulated, if you Knit it in Rstudio, you will get different numbers each time. I encourage you to try this, and explore the code for yourself. I have cheated in a few places just to avoid making a simulated data set that is too extreme, by chance. All of the code is posted below with some notes.

<a name="code">Key bits of code underlying the simulated data</a>
================================================================================

The code below can be used to generate a CSV file with simulated data as shown here. Note that you can change the significance of different regression coefficients, and their magnitudes and signs, by changing how `height` is defined within the `while` loops below.

```{r, eval = FALSE}
# The code below creates plant heights with an intercept of roughly 150
# and a beta_1 coefficient of roughly 20, with some error added into it.
# The while loop just does this to avoid any non-significant results or 
# very highly significant results that arise due to chance.
species_n <- c("species_1", "species_2");
sim_pval  <- 0;
while(sim_pval > 0.05 | sim_pval < 0.001){
    species_eg  <- sample(x = species_n, size = 100, replace = TRUE);
    species1    <- as.numeric(species_eg == "species_1");
    species2    <- as.numeric(species_eg == "species_2");
    error       <- rnorm(n = 100, mean = 0, sd = 40);
    height      <- round(150 + (species2 * 20) + error, digits = 2);
    species_ID  <- as.factor(species_eg);
    plant_data  <- data.frame(height, species_ID);
    sim_mod     <- lm(plant_data$height ~ 1 + plant_data$species_ID);
    sim_pval    <- summary(sim_mod)$coefficients[2,4];
}
write.csv(plant_data, file = "two_discrete_x_values.csv", row.names = FALSE);

# Below does the same job as above, just with three species instead of two
species_n <- c("species_1", "species_2", "species_3");
sim_pval  <- 0;
while(sim_pval > 0.05 | sim_pval < 0.001){
    species_eg  <- sample(x = species_n, size = 100, replace = TRUE);
    species1    <- as.numeric(species_eg == "species_1");
    species2    <- as.numeric(species_eg == "species_2");
    species3    <- as.numeric(species_eg == "species_3");
    error       <- rnorm(n = 100, mean = 0, sd = 40);
    height      <- round(150 + (species2 * 20) + error, digits = 2);
    species_ID  <- as.factor(species_eg);
    plant_data  <- data.frame(height, species_ID);
    sim_mod     <- lm(plant_data$height ~ 1 + plant_data$species_ID);
    sim_pval    <- summary(sim_mod)$coefficients[2,4];
}
write.csv(plant_data, file = "three_discrete_x_values.csv", row.names = FALSE);
```




